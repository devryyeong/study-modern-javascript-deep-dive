## [21] 빌트인 객체

### 21.1 자바스크립트 객체의 분류

- 표준 빌트인 객체:
- 호스트 객체:
- 사용자 정의 객체:

### 21.2 표준 빌트인 객체

- Object, Symbol, Date, Math 등 40여개
- Math, Reflect, JSON 제외 모두 인스턴스 생성 가능한 생성자 함수 객체
  - 프로토타입 메서드와 정적 메서드 제공

### 21.3 원시값과 래퍼 객체

- 표준 빌트인 생성자 함수의 존재 이유:
- 래퍼 객체: 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체
- 아래처럼 문자열에 대해 마침표 표기법으로 접근하면 래퍼 객체인 String 생성자 함수의 인스턴스가 생성되고 문자열은 래퍼 객체의 [[StringData]] 내부 슬롯에 할당됨
- 그 후 래퍼 객체의 처리가 종료되면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 우너시값으로 원래의 상태, 즉 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이

```javascript
const str = "hello";

console.log(str.length); // 5
console.log(str.toUpperCase()); // HELLO
```

### 21.4 전역 객체

- 코드가 실행되기 이전에 자바스크립트 엔진에 의해 먼저 생성되는 객체
- 브라우저 환경에서는 window(self, this, frames), Node.js 환경에서는 global
- 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체의 최상위 객체
- 생성자 함수 없음 -> 의도적으로 생성할 수 없음

**21.4.1 빌트인 전역 프로퍼티**

- 전역 객체의 프로퍼티
- Infinity
- NaN
- undefined

**21.4.2 빌트인 전역 함수**

- eval
- isFinite
- isNaN
- parseFloat
- parseInt
- encodeURI / decodeURI
- encodeURIComponent / decodeURIComponent

**21.4.3 암묵적 전역**

- 선언하지 않은 식별자에 값을 할당하면 자바스크립트 엔진은 `y = 20`을 `window.y = 20`으로 해석해 전역 객체에 프로퍼티를 동적으로 생성함
- y는 전역 객체의 프로퍼티가 되어 전역 변수처럼 동작하는 현상
- 전역 변수는 아니므로 변수 호이스팅이 발생하지는 않음

## [22] this

### 22.1 this 키워드

- 동작을 나타내는 메서드는 자신이 속한 객체의 상태(프로퍼티)를 참조하고 변경할 수 있어야 함
- 이때 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 함

- this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수.
- this를 통해 자신이 속한 객체 / 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있음
- 단, this가 가리키는 값(this 바인딩)은 함수 호출 방식에 의해 동적으로 결정됨

- Java, C++ 같은 클래스 기반 언어에서는 this는 언제나 클래스가 생성하는 인스턴스를 가리키지만, 자바스크립트의 this는 함수가 호출되는 방식에 따라 this 바인딩이 동적으로 결정됨

### 22.2 함수 호출 방식과 this 바인딩

- this에 바인딩될 값은 함수 호출 방식에 따라 동적으로 결정됨
- 함수 호출 시점에 결정됨
- 함수를 호출하는 방식: (일반 함수 호출, 메서드 호출, 생성자 함수 호출, Function.prototype.apply/call/bind 메서드에 의한 간접 호출)

**22.2.1 일반 함수 호출**

- 기본적으로 this에는 전역 객체가 바인딩됨
- 어떠한 함수라도 일반 함수로 호출되면 this에 전역 객체가 바인딩됨
  - 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩됨
  - 콜백 함수가 일반 함수로 호출된다면 콜백 함수 내부의 this에도 전역 객체가 바인딩됨

**22.2.2 메서드 호출**

- 메서드 내부의 this에는 메서드를 호출한 객체가 바인딩됨 단, 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩되는 것

**22.2.3 생성자 함수 호출**

- 생성자 함수 내부의 this에는 생성자 함수가 미래에 생성할 인스턴스가 바인딩됨

**22.2.4 Function.prototype.apply/call/bind 메서드에 의한 간접 호출**

- apply, call, bind 메서드는 모든 함수가 상속받아 사용 가능
- apply, call 메서드의 본질적인 기능은 함수를 호출하는 것이므로, 함수를 호출하면 첫 번째 인수로 전달한 특정 객체를 호출한 함수ㅢ this에 바인딩함

## [23] 실행 컨텍스트
### KEYWORD
  - 자바스크립트가 스코프를 기반으로 식별자와 식별자에 바인딩된 값을 관리하는 방식
  - 호이스팅이 발생하는 이유
  - 클로저의 동작 방식
  - 태스크 큐와 함께 동작하는 이벤트 핸들러
  - 비동기 처리의 동작 방식

### 23.1 소스코드의 타입

- 전역 코드:
- 함수 코드:
- eval 코드:
- 모듈 코드:

### 23.2 소스코드의 평가와 실행

- 소스코드 평가: 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행해 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록
- 평가 과정이 끝나면 순차적으로 실행되고(런타임) 실행 결과가 다시 실행 컨텍스트가 관리하는 스코프에 등록됨  
  ➡️실행 컨텍스트 스코프에 변수가 등록되어 있는지 확인 후 선언된 변수라면 값을 할당하고 할당 결과를 실행 컨텍스트에 등록하여 관리함

### 23.3 실행 컨텍스트의 역할

- 실행 컨텍스트: 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역
  - 식별자(변수, 함수, 클래스)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘
- 식별자와 스코프는 실행 컨텍스트의 <u>렉시컬 환경</u>으로 관리하고 코드 실행 순서는 <u>실행 컨텍스트 스택</u>으로 관리
  - 렉시컬 환경: 일정한 <u>범위</u>. 전역 / 함수 / eval / 모듈 각각의 <u>범위</u>. 그 안에서의 {변수, 함수, 클래스 등}의 식별자들에 대한 정의.
    ➡️ 즉, _스코프에 의해 전역과 지역 범위를 구분하고, 생성된 식별자를 스코프에 따라 등록해 값을 관리하고, 코드의 실행 순서(함수 호출 등)를 관리_

### 23.4 실행 컨텍스트 스택

- 전역 코드와 여러 함수들을 실행 컨텍스트 스택에 push하고 pop하면서 코드의 <u>실행 순서</u>를 관리
- 스택 구조라 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행 중인 코드의 실행 컨텍스트

### 23.5 렉시컬 환경

- 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조 (실행 컨텍스트를 구성하는 컴포넌트의 일부)
- 스코프와 식별자를 관리함

- 키와 값을 갖는 객체 형태의 스코프를 생성하여 식별자를 키로 등록해 식별자에 바인딩된 값을 관리 (실질적으로 값을 구분하여 저장하는 저장소 역할)
- EnvironmentRecord(환경 레코드)와 OuterRexicalEnvironmentReference(외부 렉시컬 환경에 대한 참조) 2개의 컴포넌트로 구성됨

### 23.6 실행 컨텍스트의 생성과 식별자 검색 과정
- 전역 객체 생성 -> 전역 코드 평가 -> 전역 코드 실행 -> foo 함수 코드 평가 -> foo 함수 코드 실행 -> bar 함수 코드 평가 -> bar 함수 코드 실행 -> bar 함수 코드 실행 종료 -> foo 함수 코드 실행 종료 -> 전역 코드 실행 종료

### 23.7 실행 컨텍스트와 블록 레벨 스코프
- let, const 키워드는 블록 레벨 스코프를 갖고, 이 키워드들 {함수, if문, for문, while문, try/catch문} 내에서 변수로 선언되면 별도의 실행 컨텍스트를 생성하는 것이 아니라 코드 블록을 위한 새로운 렉시컬 환경 생성
- 반복문의 경우 반복해서 실행될 때마다 독립적인 렉시컬 환경을 생성해 식별자의 값을 유지함
- OuterLexicalEnvironmentReference가 전역 실행 컨텍스트의 Global Lexical Environment를 참조하고 있다가 BLOCK Level Environment가 덮어씌워졌다가, 블록 레벨의 코드가 실행이 끝나고 실행 컨텍스트 스택에서 제거되면 없애서 다시 전역으로 복귀
