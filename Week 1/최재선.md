# 함수

  > 정의
 - 일련의 과정을 문(statement)으로 구현, 코드 블록으로 감싸서 하나의 실행 단위로 정의 것

 > 내부로 입력을 전달받는 변수
 - 매개 변수(parameter)
 - 인수 (argument)
 - 반환 값(return value)

 > 사용하는 이유
 - 코드의 재사용성
 - 유지보수의 편의성
 - 코드의 신뢰성

 ### 리터럴

 리터럴은 사람이 이해할 수 있는 문자 혹은 약속된 기호를 사용해 값을 생성하는 표기 방식을 의미한다

 - function 키워드, 함수 이름, 매개 변수 목록, 몸체로 구성

 ```js
 const f = function add(x, y) {
  return x + y;
 }
 ```

 - 위의 구문에서 키워드(function), 매개 변수 목록(x, y >> arguments), 몸체 ({ ... } 코드 블럭)
 - 일반적으로 arguments는 객체로 전달받거나 개수가 3개 이상 넘지 않는 것을 권장
 

 즉 리터럴은 값을 생성하기 위한 표기법 >> 함수는 객체

 ### 함수의 정의
  매개변수(arguments), 실행할 문들(code block), 반환할 값(return value)를 지정하는 것을 의미

 #### 함수의 종류

 1. 함수 선언문

```js
function name(arg1, arg2) {
  // code block;
  return 1; // return value;
}

// 이름 생략 불가능 (익명 함수 X)
function (arg1, arg2) {
  return 1;
}

```
함수 선언문은 표현식이 아니라 문이다.
 - 함수의 선언 시, 평가 값으로 표현식이 아닌 undefined가 평가 된다

따라서 표현식이 아닌 문은 변수에 할당할 수 없다.

```js
const name = function name(arg1, arg2) {
  return arg1 + arg2;
}

console.log(name(2, 5)) // 7
```

위의 코드가 가능한 이유는 자바스크립트 엔지닝 코드의 문맥에 따라 도잉ㄹ한 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우와, 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있기 때문이다.

- {}은 블록문일 수도 있고 객체 리터럴일 수도 있다
- 위와 같은 중의적인 블록은 문맥에 따라 해석 방법이 달라진다.
  - {}이 단독으로 존해나는 경우
    - 블록문으로 해석
  - {}이 평가되어야 할 문맥 (ex, 할당 연산자의 우변 const a = {})
    - 객체 리터럴로 해석

따라서, 위와 같은 경우는 function이 할당 연산자의 우변에서 평가되어야 할 문맥으로 판단되어, 객체 리터럴로 해석되는 것이다.

```js
// 함수 선언문으로 해석, 즉 {}이 블록문으로 해석 됨
  function foo() { console.log('foo') }
  foo();

// 함수 리터럴 표현식으로 해석, 
  (function bar() { console.log ('bar') });
        bar() // ref error0
```

위에서 bar에 할당된 메모리 참조가 없으므로 호출이 불가능하다.
반면, 선언문으로 해석한 foo는 함수 객체를 가리키는 식별자로 foo가 할당되었다. (자바스크립트가 암묵적으로 생성한 식별자) 따라서 호출이 가능하다

결론적으로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 생각할 수 있다.

2. 함수 표현식

js의 함수는 객체 타입의 값이며, 일급 객체이다.

> 일급 객체란
- 값처럼 변수에 할당 할 수도 있고, 프로퍼티 값이 될 수도 있으며, 배열의 요소가 될 수도 있다.


```js
// 함수 선언문으로 정의한 함수를 함수 표현식으로 바꿔서 정의하면 다음과 같다.
const name = function (x, y) {
  return x + y;
};

console.log(name(2, 5)); // 7
```

### 함수 선언문 vs 함수 표현식

- 선언문은 자바스크립트 런타임 이전에 엔진에 의해 먼저 실행된다. (호이스팅 가능)
- 표현식은 변수 할당문을 한번에 기술한 축약 표현과 동일하게 작동한다. 즉, 변수 선언은 런타임 이전에 실행되 undefined로 초기화 되고, 할당문은 할당문이 실행되는 시점인 런타임에 평가된다.

> Function 생성자 함수
- 일반적이지 않고 바람직하지 않다.
- 클로저를 생성하지 않는다.
- 선언문이나 표현식으로 생성된 함수와 다르게 동작한다


3. 화살표 함수

화살표 함수는 function 키워드 대신 화살표를 사용해 간단한 방법으로 함수를 선언 할 수 있다.

- 익명 함수로 정의된다.
- 기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며, arguments객체를 생성하지 않는다.

# 스코프

스코프는 js의 namespace라고 보면 된다.
특정 범위(지역 범위, 전역 범위)에서 유효한 값들의 범위를 말한다

- 일반적으로 스코프는 전역 스코프, 지역 스코프로 나뉜다.
- 지역 스코프는 함수 몸체 내부를 말하며, 전역 스코프는 코드의 가장 바깥 영역을 말한다.
- var로 선언된 변수는, 함수가 아닌 block scope에 묶이지 않는다.

스코프는 js 런타임 실행 시, 스코프 체인을 통해 각 변수마다 정해질 수 있으며, 계층적으로 안에서 밖으로 체인을 따라 변수의 할당된 값을 찾는다.

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 10;
bar(); // 1;
```

